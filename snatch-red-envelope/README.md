# snatch-red-envelope Demo

-----



## 一、发和抢红包（后端 ）springboot + redis（使用jedis）



----

### 							简短思路介绍

-----

​	前端页面完成基础的发红包和抢红包按钮，在处理高并发情况采用了分布式锁，鉴于能力有限，在大量用户情况之可以保证大多数ok。



### 1.1 详细设计思路

----

​	不妨用生活日常来表示高并发处理的进阶过程，大体的流程，冒险者去任务栏接任务。

第一种，采用synchronized 可以理解为，每个人在排队接取任务，上一个接取完毕才开始下一个

第二种就是我采用的分布式锁，简单来说就是每一个人接取任务，同时用一张锁表（锁的名称为唯一标识且不可以重复）记录任务被锁，每一个人去写就会先去锁表登记，

```html
if  登记成功
	拿到锁，
else (表明取到了相同的任务)自旋一直尝试去取

一直没取到重新去取任务（未完成）
```

但是因为假如拿到锁的人一直无法完成接取，那么就会产生死锁，所以对信息设置超时时间

```java
jedis.expire
```

当然还有一种情况，用户快速点击二次，会不会抢到二个红包，要保证操作的原子性（未完成）。



### 问题

-----

1、详情可见test文件

```java
//        Jedis jedis = new Jedis("127.0.0.1",6379);
//        jedis.auth("123456");
        for (int i = 0 ; i < 10 ; i++) {
            new Thread(()->{
                Jedis jedis = new Jedis("127.0.0.1",6379);
                jedis.auth("123456");
                Long llen = jedis.llen("1");
                System.out.println(llen);
            }).start();
        }
```

至于为什么会写这个测试，这主要因为，我一报redis数据查询错误，我想了想，起初我在静态文件里面加载jedis，这个会导致jedis会在系统编译完就会初始化jedis，当你用同一个jedis去数据库查询，就会产生语法错误，

```java
: ERR Protocol error: expected '$', got ' '] with root cause
```

解决：将jedis初始化放到方法体中，即编译后,保证jedis不复用



### 测试（三次平均值）

------

| 测试数量\数值 | 成功 | 时间（秒） |
| ------------- | ---- | ---------- |
| 100           | 100  | 0.148      |
| 1000          | 1000 | 0.882      |
| 10000         | 2338 | 13.66      |

 

一万条还是有点难，





### 扩展

-----

