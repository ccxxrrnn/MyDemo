# snatch-red-envelope Demo

-----



## 一、发和抢红包（后端 ）springboot + redis（使用jedis）



----

### 							简短思路介绍

-----

​	前端页面完成基础的发红包和抢红包按钮，在处理高并发情况采用了分布式锁，鉴于能力有限，在大量用户情况之可以保证大多数ok。



### 1.1 详细设计思路

----

​	不妨用生活日常来表示高并发处理的进阶过程，大体的流程，冒险者去任务栏接任务。

第一种，采用synchronized 可以理解为，每个人在排队接取任务，上一个接取完毕才开始下一个

第二种就是我采用的分布式锁，简单来说就是每一个人接取任务，同时用一张锁表（锁的名称为唯一标识且不可以重复）记录任务被锁，每一个人去接任务之前都会先去锁表登记，

```html
从任务set集合 利用redis set随机抽取 取到任务
if  登记成功（即任务没有人拿走）
	拿到锁，
else if 取了任务但是ttl>0 (有人取了的任务，但还没有解锁)
	加长锁的持有时间（这是为了防止可重入锁）
可以设置一些休眠时间(减少服务器压力)
一直没取到重新去取任务
```

但是因为假如拿到锁的人一直无法完成放锁，那么就会产生死锁，所以对信息设置超时时间

```java
jedis.expire
```

用户快速点击二次，会不会抢到二个红包，要保证操作的原子。



### 问题

-----

1、详情可见test文件

```java
//        Jedis jedis = new Jedis("127.0.0.1",6379);
//        jedis.auth("123456");
        for (int i = 0 ; i < 10 ; i++) {
            new Thread(()->{
                Jedis jedis = new Jedis("127.0.0.1",6379);
                jedis.auth("123456");
                Long llen = jedis.llen("1");
                System.out.println(llen);
            }).start();
        }
```

至于为什么会写这个测试，这主要因为，我一报redis数据查询错误，我想了想，起初我在静态文件里面加载jedis，这个会导致jedis会在系统编译完就会初始化jedis，当你用同一个jedis去数据库查询，就会产生语法错误，

```java
: ERR Protocol error: expected '$', got ' '] with root cause
```

解决：将jedis初始化放到方法体中，即编译后,保证jedis不复用



### 测试（三次平均值）

------

| 测试数量\数值 | 成功 | 时间（秒） |
| ------------- | ---- | ---------- |
| 100           | 100  | 0.148      |
| 1000          | 1000 | 0.882      |
| 10000         | 2338 | 13.66      |

 

一万条还是有点难，应该采用redis的主从复制，多个redis





### 扩展

-----

